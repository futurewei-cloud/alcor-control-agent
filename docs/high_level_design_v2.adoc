= Cloud Fabric Alcor Control Agent
Eric Li <sze.li@futurewei.com>
v0.1, 2021-02-15
:toc: right

[width="100%",options="header"]
|====================
|Title|Authors|Version
|Cloud Fabric Alcor Control Agent v2|@er1cthe0ne|0.1
|====================

== Summary

The Cloud Fabric Alcor Control Agent (ACA) v2 is based on experience gained on the successful release of Alcor and also feedback from the community. It serves as a compute host level network configuration manager, for the next generation Cloud Native SDN Platform.

image::images/Agent_v2.jpg["Component diagram", width=800, link="images/Agent_components.jpg"]

== Layered Architecture

There are four major layers in ACA v2.

=== Communication Layer

The communication layer contains the gRPC and MQ implementation that's active at the same time. It includes the implementation of communication manager which transfers the goal state messages to the goal state handler for processing. The goal state handler will call into core networking programming interface to process.

=== DHCP/DNS Implementation

To allow flexiblity of different DHCP/DNS programs (e.g. OVS, dnsmasq etc.), ACA provides a DHCP/DNS programming interface to support any kinds of implementation. The current DHCP implementation is based on ovs with on demand DHCP responder. (https://github.com/er1cthe0ne/alcor-control-agent/blob/master/docs/dhcp_programming.adoc) 

=== Dataplane Abstraction Layer

To support different dataplane implementations (e.g. OVS and Mizar), abstraction layer was implemented in ACA. All the interfaces here are the same for all dataplane. 

==== Core Network Programming Interface

This interface is used to program VPC/Subnet/Port configurations on compute hosts. All dataplane implementation (OVS or mizar or other) will extend from this which will allow easy switching between different dataplane implementation.

==== L2 Programming Interface

This interface is used to program L2 switch information, it manages customer ports based on the goal state message. It also handle L2 neighbors dataplane programming.

==== L3 Programming Interface

This interface is used to program L3 routing information, it also including programming of subnet routing rules on routers. It manages routers and router rules based on the goal state message. It also handle L3 neighbors dataplane programming and communication.

=== Work Item Executor

Work item executor is used to execute the configuration updates for different dataplane implementation. It runs the workitems in parallel by default. There is a huge performance improvement when updating 10s or 100s of ports in parallel instead of updating serially based on data. 

=== On-Demand Engine

On-Demand Engine is responsible to deal with DHCP and ARP requests, also future on-demand routed and unknown traffic which need information from higher level Network Configuration Manager (https://github.com/er1cthe0ne/alcor/blob/design/AGA/docs/modules/ROOT/pages/infra_services/NCM_design.adoc). Those packets will be "punt" from OVS to ACA for processing. This component can be broken out into a micro program to keep the dataplane alive if ACA is down or getting upgraded.

== Recommended Code Changes

This session list the proposed code change location and details to support the new on demand handling of unknown packets:

. add [table=20 (unicast), priority=25(mid),actions=CONTROLLER] in ACA_OVS_L2_Programmer::setup_ovs_bridges_if_need function. This is the punt rule to send the unknown packet for ACA for on demand processing.
. update the PushNetworkResourceStatesStream code to allow flexible stream reader and writer, plus unit test for that
. put all the new files related to on-demand engine under a new folder under src/on_demand, start with aca_on_demand_engine.cpp, with a singleton class named ACA_On_Demand_Engine
. update ACA_OVS_Control::parse_packet under aca_ovs_control.cpp to handle unknown packet, send to class ACA_On_Demand_Engine function for processing
. class ACA_On_Demand_Engine will have a function to handle unknown packet, it will start a new thread for process the unknown packet in flight, need to limit the processing if there are too many unknown packets generated by a particular customer port
.. generate a unique UUID from aca as the request ID to use below
.. craft a GoalStateRequest message based on the unknown packet's tunnel id, source/destination IP, source/destination port, ethertype and protocol
.. record the request ID and a signal object into a hashtable for tracking, then send the crafted GoalStateRequest to NCM using PushNetworkResourceStatesStream
.. the new thread will keep waiting (with a configurable timeout) for the reply from NCM based on signal object
... if NCM sends port configuration with Operation = ROUTABLE, then releasing the unknown packet to OVS
... if NCM sends port configuration with Operation = NOT_ROUTABLE, then log and drop unknown packet
... if ACA timed out waiting for port configuration from NCM, then log and drop unknown packet, may do retry
... all the situation above should clean up the entry in hashtable afterward

